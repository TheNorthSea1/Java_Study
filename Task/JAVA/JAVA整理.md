# 一、基础概念

1. **简述什么是JDK、JRE和JVM**？
   - **JDK**：Java开发工具包（Java Development Kit），是Java编程的基础，包含了Java编译器、JVM、各种库和工具。
   - **JRE**：Java运行时环境（Java Runtime Environment），是运行Java程序所必需的环境，包括JVM和核心类库。
   - **JVM**：Java虚拟机（Java Virtual Machine），是Java程序的运行环境，能够将Java字节码转换为机器码并执行。
2. **Java的四类八种基本数据类型是什么**？
   - 整数类型：byte、short、int、long。
   - 小数（浮点）类型：float、double。
   - 布尔类型：boolean。
   - 字符类型：char。
3. **&和&&的区别**？
   - **&**：按位与运算符，用于对两个操作数执行位级别的逻辑与操作。无论左右两边的表达式真假如何，都会执行。
   - **&&**：逻辑与运算符，用于对两个操作数执行逻辑与操作。具有短路性，如果第一个表达式为假，则直接返回假，不再执行第二个表达式。
4. **简述什么是标识符，及其定义的规则**？
   - 标识符就是名字，用于给变量、方法、类等命名。
   - 规则：数字不能开头，不能使用关键字起名字，特殊符号只有_和$，可以是26个大小写英文字母、数字0-9等。

# 二、面向对象

1. **什么是面向对象，请详细说明（分别解释封装、继承和多态）**？
   - **面向对象**：是一种以事物为中心的编程思想，具体分为封装、继承和多态。
   - **封装**：通过private关键字将事物的属性和行为封装起来，对外通过setter和getter提供公共的访问方式，提高了代码的安全性。
   - **继承**：让类与类之间产生子父级的关系，子类可以去使用父类的资源，提高了代码的复用性。
   - **多态**：事物的多种形态，发生多态的前提是必须有继承、有方法的重写、有父类的引用指向子类对象。
2. **接口与抽象类的区别**？
   - **接口**：
     - 是一种完全抽象的类，只包含常量和抽象方法的定义，没有变量和方法的实现。
     - 一个类可以实现多个接口。
     - 不能包含属性（成员变量），能声明方法，但方法中不包含代码实现。
     - 实现类必须实现接口的所有方法。
   - **抽象类**：
     - 是一个可以包含抽象方法和具体方法实现的类，它不能被实例化，只能被子类继承。
     - 一个类只能继承一个抽象类。
     - 可以包含属性与方法，方法中可以包含具体实现。
     - 子类继承抽象类必须实现抽象类的所有方法，否则继承的类还是抽象类。
3. **final关键词有哪些用法**？
   - 修饰类：表示该类不能被继承。
   - 修饰方法：表示该方法不能被重写，但是可以被正常调用。
   - 修饰变量：表示该变量为常量，一旦赋值后不可更改。
4. **成员变量和局部变量的区别**？
   - **物理位置**：成员变量在类中方法外，局部变量在方法中或方法定义的小括号里面。
   - **内存位置**：成员变量在堆内存中，局部变量在栈内存中。
   - **生命周期**：成员变量随着对象创建而产生，随着对象的消失而消失；局部变量随着方法的调用而产生，随着方法调用结束而消失。
   - **有无默认值**：成员变量有默认值（整数0，小数0.0，字符‘\u0000’，布尔false，引用数据类型null），局部变量没有默认值，使用的时候必须先赋值。
5. **this和super都能用到哪些地方**？
   - **this**：用于指代当前对象，可以在成员方法中、构造方法中、初始化块中使用。
   - **super**：用于指代父类对象，可以在成员方法中、构造方法中、初始化块中使用，还可以用于调用父类的静态方法或静态变量（但通常不推荐这样做，因为可以直接通过类名调用）。

# 三、异常处理

1. **简述Java的异常分类**？
   - **受检异常（Checked Exception）**：继承自Exception类，编译器强制要求必须处理的异常，可以使用try-catch块捕获或者在方法上使用throws关键字声明抛出。
   - **运行时异常（Runtime Exception）**：继承自RuntimeException类，通常由程序错误导致，不需要显式捕获或声明抛出，可以选择性地处理。
   - **错误（Error）**：继承自Error类，通常由严重的系统问题导致，无法恢复或处理。
2. **列出一些常见的运行时异常**？
   - **NullPointerException**：当尝试访问空对象引用时抛出。
   - **ArrayIndexOutOfBoundsException**：数组索引越界时抛出。
   - **IllegalArgumentException**：当方法接收到非法参数时抛出。
   - **ArithmeticException**：在算术运算中出现错误时抛出，如除数为零。
   - **ClassCastException**：当尝试将对象强制转换为不兼容类型时抛出。

# 四、集合框架

1. **Collection与Collections的区别**？
   - **Collection**：是单列集合的顶层父接口，用于存储一系列的元素。
   - **Collections**：是一个包含了各种静态方法的工具类，提供了对集合进行排序、查找、同步等操作的方法。它不是集合类，而是一组操作集合的工具方法。
2. **HashMap和HashTable的区别**？
   - **HashMap**：是非线程安全的，允许键和值都可以为null，通过Iterator进行迭代，是JDK 1.2引入的新集合类。
   - **HashTable**：是线程安全的，不允许键和值为null，通过Enumeration进行迭代，是早期的集合类，现在通常建议使用HashMap替代HashTable。

# 五、JVM与内存管理

1. **简述JDK8的内存结构**？
   - **程序计数器**：记录当前线程执行的字节码指令地址。
   - **虚拟机栈**：存储方法调用的栈帧，包括局部变量表、操作数栈等信息。
   - **本地方法栈**：为虚拟机执行本地方法服务。
   - **堆内存**：存放对象实例，被所有线程共享。
   - **方法区**：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   - **运行时常量池**：存放编译器生成的各种字面量和符号引用。
   - **直接内存**：与堆内存不同，直接内存通过Native函数库直接分配内存，不受Java堆大小的限制。
2. **列举你知道的几个JVM参数**？
   - **-Xms**：设置初始堆内存大小。
   - **-Xmx**：设置最大堆内存大小。
   - **-Xss**：设置每个线程的栈大小。
   - **-XX:PermSize**：设置永久代（JDK 8之前）或元数据区（JDK 8+）初始大小。
   - **-XX:MaxPermSize**：设置永久代（JDK 8之前）或元数据区（JDK 8+）最大大小。
   - **-XX:+UseParallelGC**：启用并行垃圾回收器。
3. **简述发生StackOverflowError和OutOfMemoryError的场景**？
   - **StackOverflowError**：当方法调用的堆栈太深而导致栈溢出时抛出。
   - **OutOfMemoryError**：当尝试使用更多内存超出JVM可分配的限制时抛出。

# 六、其他

1. **第一次执行String str = new String(“abc”)创建了几个对象，为什么**？
   - 第一次执行`String str = new String(“abc”)`时，创建了两个对象：一个是“abc”字符串常量，它存在于字符串常量池中；另一个是`new String(“abc”)`创建的新的字符串对象，它存在于堆内存中。
2. **String、StringBuffer、StringBuilder有什么区别**？
   - **String**：是不可变的，每次对字符串进行操作都会生成一个新的字符串对象，效率较低。
   - **StringBuffer**：是可变的，可以进行字符串的修改操作，并且不会生成新的字符串对象。它是线程安全的，适用于多线程环境。
   - **StringBuilder**：也是可变的，可以进行字符串的修改操作，并且不会生成新的字符串对象。但它是非线程安全的，适用于单线程环境，效率更高。